# 计算机基础

参考:https://cnblogs.com/linhaifeng/p/6523843.html#_label5

![](D:\picture\c++\38.jpg)

## 产品开发流程

![](D:\picture\c++\39.jpg)

![40](D:\picture\c++\40.jpg)



## 服务器

## ![](D:\picture\c++\62.jpg)

## CPU

CPU内部是有指令集的,这些指令集供用户调用,去控制其他硬件的运行.不会自发运行

类似你叫小明跑去xx包子铺买包子(取指),但你没有告诉他怎么跑,怎么掏钱(怎么控制他的肉体),这些是他自己翻译、运算(解码)出来的.



```
CPU 内部有 指令集(分为两种)

①精简指令集       单条指令完成的事少,更不容易出错,稳定性较好,但设计时更复杂

②复杂指令集 x86	一条指令做的事多 完成一个功能需要的条数少 稳定性较差 ,设计时更简单



按功能分也可以分为 控制指令集	运算指令集



小型机用的是精简指令集,更加稳定,性能高,但设计复杂,价格贵

去IOE运动后,小型机逐渐过时,但一些好的设计被保留并应用
```



```
人--->cpu----->硬件

外存->内存->(缓存)->(寄存器)CPU(寄存器)->(缓存)->内存->外存

软件的启动 从硬盘到内存 可以换一个好硬盘(固态硬盘)

操作系统也是软件,所以开机慢就可以买一个固态硬盘,然后把系统装在固态硬盘里

ps:软件,也就是一堆代码,安装在硬盘里,软件的运行是把它们加载在内存中

​	所以计算机硬盘的大小决定了能够安装软件的数目,计算机内存的大小决定了计算机能够同时运行的软件的数目
```





```
linux优化机制

cpu ->内存 ->硬盘	  buffer  

硬盘->内存->cpu		cache  占的是内存空间 , 只能缓存一部分数据(不一定会用) , 由操作系统决定. 



*内存空间不够用时,Linux允许程序员释放chache空间

*在释放buffer前,一定要通知操作系统先把buffer中的数据刷到硬盘中 

​	两种方式

​		第一种   linux自身的优化机制,对于buffer,在其数据刷到硬盘后,才会释放其内存空间

​		第二种   通过命令强制操作系统刷新buffer , 使其数据刷到硬盘
```



```
内核态与用户态:

​	操作系统	①控制硬件运行

​			   ②内核、接口


​	内核态->操作系统正在控制硬件

​	用户态->应用程序正在运行

​	

​	发数据 应用程序(QQ)>操作系统(->接口->内核代码运行)->硬件(网卡)

​	收数据	硬件(网卡)->操作系统->应用程序
```

​                                                     

```
一级缓存 集成在核内部 , 二级缓存不是

Intel  cpu	多核共享二级缓存		

​	优点:数据共用,无需处理数据同步问题

​	缺点:需处理数据竞争问题

AMD    cpu 	每个核单独配备二级缓存	

​	优点:无需处理数据竞争问题

​	缺点:各二级缓存数据独立,当不同的核要处理相同数据时,需处理数据同步问题				
```

​					

## 存储器

BIOS 产生的数据(如用户密码，启动项优先级的调整，计算机的时间等)都存放在cmos中.也就是说,开机时cmos相当于硬盘,ROM相当于内存,启动后是cpu ram 硬盘.



CMOS存储器和递增时间的电路由一小块**主板电池驱动**，所以，即使计算机没有加电，时间也仍然可以正确地更新

如果把cmos的电池扣掉,BIOS配置的数据就丢了,恢复出厂设置

## 去IOE运动

![](D:\picture\c++\72.jpg)

## 硬盘

 机械硬盘 (HDD,Hard Disk Drive)

靠磁存数据,有寿命,易损坏

1.两个指标:容量	速度(主轴转速)

2.慢在找数据(按特定转向,在磁道上找)

```
转一圈花费的时间：0.008s

​			平均寻道时间：5ms												(找磁道,基地址)

​			平均延迟时间：转半圈花费的时间4ms				 (找偏移地址)

也就是平均找数据画9ms,足够cpu运行上百万条指令			
```



不要直接关电源

正常关机时,操作系统会先将机械手臂归到槽位中

硬盘告诉运转时,突然断电,操作系统来不及反应,机械手臂还在由于惯性旋转磁盘上,就会损坏磁盘



固态硬盘(SSD,Solid State Drive)

靠电子存数据,速度快,有寿命



```
分区	对硬盘分区

虚拟内存  在硬盘中	防止内存不够用

当内存不够用时,可读不可写,运行指令产生数据时由于无法写入内存,cpu得等,电脑(所有程序)就卡了,要么重启,要么等,建议重启

解决方案:监控内存状态,防范于未然



Linux优化机制(内存不够用时)

往swap里放一些暂时不用的数据,留出内存空间

随机找一个进程关闭,释放内存
```







## I/O

设备控制器	设备本身



主板上每个接口都连一块芯片(设备控制器)



驱动程序(控制硬件的细节)	不归操作系统管,归硬件生产商自己写.安装在操作系统中

接口(供操作系统调用驱动程序)	要按操作系统的标准写



计算机生产厂商

计算机	I/O设备

DELL计算机(Dell接口->设备控制器)	硬盘(某另一牌子)	这时把硬盘插在设备控制器上,就要解决兼容性问题.

计算机生产厂商公布设备控制器的标准->I/O生产厂商(这里指,硬盘)针对其硬件开发驱动程序





![](D:\picture\c++\9c.png)

PCI桥 ----> 内存(高速设备)

ISA桥 ----> I/O(低速设备 )



## 计算机启动过程

开机前按ESC、F2可使计算机停在BIOS



```
BIOS,扫描设备,把启动盘的mbr读入内存->grub,载入内核,启动操作系统->让BIOS检测驱动程序
```

不按,就会执行启动项	扫描顺序	启动优先级列表	找操作系统所在启动设备(启动盘)

读取启动设备的第一个扇区的大小(MBR,主引导记录,Master Boot Record)(512B)

```
512B	启动盘

446B 	bootloader(启动装载程序,一个统称) ->grub程序->读到内存

46B	    分区信息

2B		结束标志位

```

grub相当于排头兵,探路.大部队还在硬盘.

这之后操作系统内核的载入归grub管

## ups设备

集群:多个相同设备(如 双电源 、多网口)

好处:防止单点故障,提高性能,为排除故障争取时间



单点故障后,应立即排查并解决问题.

备用设备的运行,只是在为解决问题争取时间



**电源**

```
	风扇 -> 散热



​	双电源模块 -> 单点故障后,设备仍能运行,保证设备运行稳定性

​		两个电源模块最好接在不同的插排上,防止其中一个插排坏了,两个都不能工作

​    

​	 服务器->插排->UPS->机房电源->市电

​		 市电断电全都白搭 . 

​         所以正规机房会接 两股市电->UPS设备(不间断电源,虚电池) , 

​         市电断后 , 取决于功率,个人PC的UPS仍能供电20min左右 , 机房的则可以持续供电几个小时

​		 这时,应当立马保存数据
```

​		![](D:\picture\c++\73.jpg)

**IDRAC(远程管理卡)**

```
	给IDRAC配一个IP地址,就可以远程控制服务器的开关机

作用:

​		软件出问题,可以远程控制.

​		硬件出问题,异常关机,无法远程连接,没有IDRAC,就只能坐车到机房管理.

​		 有了IDRAC就可以通过IP远程操控
```



**网线**

```
	线序 

​		橙白橙,绿白蓝,蓝白绿,棕白棕

​		需要额外找视频补充了解制作方式和结构


```

**网卡**

```
	根据传输数据的带宽分为

​	千兆网卡	双绞线	速度慢

​	万兆网卡	光纤		速度快	

​	需要额外找视频补充了解制作方式和结构

关键词 服务器 光纤模块
```



**网口**

```
多个网口->一个断了,另一个还能运行,保证设备运行稳定性




```

​		

## 硬盘接口

IDE (integrated development environment)				 并口		![](D:\picture\c++\76.jpg)		  每个针脚发送数据时会相互干扰



SATA (Serial Advanced Technology Attachment） 	串口		![](D:\picture\c++\75.jpg)			    传输速度,稳定性,纠错能力都强于IDE

SCSI (Small Computer System Interface)                  			                                                  针对小型机

SAS (SATA + SCSI,Serial Attached SCSI)		                                                                           目前服务器硬盘接口主流



一般公司的底层设施 选择 普通性价比高服务器 + 软件、技术手段 使服务器变强大



高并发场景下,冷热数据区分对待

热数据	SSD + SAS/SATA	用户 经常 访问的数据

冷数据	HDD + SAS             用户 不经常 访问的数据





RAID(阵列卡,Redundant Array of Independent Disks,"独立磁盘构成的有冗余能力的阵列")

![](D:\picture\c++\77.jpg)

raid 0 

以两块盘为例,做成raid0(集群)后对外只暴露一块盘

数据存储(分散到两个硬盘存储)

​	以写入数据 01000001 为例 将这八个数码分别记为 $x_1,x_2...x_8$.两块硬盘分别记为 硬盘A,硬盘B

​    写入过程如下: 将$x_1$写入A,将$x_2$写入B ; 将$x_3$写入A,将$x_4$写入B...

冗余性(能坏几块盘):由于把一个数据分散到多个盘存储,所以raid0不允许坏任意一块盘



①好处:读写性能高

​		 速度上,更快 (两块盘的读写速度,分散了读写压力)

​         空间上,更大 (两块盘的空间)

②缺点:数据安全问题,坏一块盘,数据就没了.

③特点:追求速度,不考虑安全

④具体应用场景:集群服务器,用来跑代码的,但真正的数据并不存储在这个服务器上.

​	以某个应用软件为例,假如你的硬盘坏了,这个软件也就丢了,却可以再下载,下载的是它的代码

​     但这个程序运行过程中产生的数据,没了就真的没了

​     所以数据才是关键

​	解决方案:不要把数据放在本地